
# On chapter 3 #

I have just finished exercise 3.7

Things are looking pretty interesting, however i think I'm going to skip the next exercise, like i get the point that the order of evaluation matters, so i wont waste the time doing the exercise, i don't think its too hard either way.

A couple of seconds after writing that, i suddenly decided to give it a shot.

- **Exercise 3.25** : TODO : Dunno why but my brain just couldn't concentrate enough for it.
Also I'm skipping exercise 3.26 for now, just doesn't seem very interesting.
The next exercise however, i might fiddle with a bit, because that memoization function seems to only take one argument, i wonder if i can ... generalize that.
- **Exercise 3.30** TODO ; that figure confuses me where are the inputs .. where are the outputs? 
Also this seems like the fun exercices you can only do and hope are correct ...
... And THEN *after* reading the rest of the material, you can actually go back and test zhat you've written ...
I guess i should keep quiet and git gud at interpreting the code in my head.

## On concurenncy

Theres an exercise (not in the book) that I was inspired to do from reading the 'Mechanisms for controlling concurenncy'.
Given two sets representing three ordered events (x y z) and (a b c), write a function that outputs all the possible interleavings os these events).`

## Notes about a certain strem process ##

The erastosthenes sieve was particularly clever tbh, .... of course, in haskell this is even more elegant, but that doesn't take away from the elegance of the implemented procedure.

## STREAMMMMMMMMS ##

I will need to do this section again.

Streams are easy to understand, *atomically* but when the definitions of functions get complicated, I often find myself lost.

